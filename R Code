# Calf survey project

# Objectives:
# 1 -> Characterize early life management practices
# 2 -> Evaluate the relationship with profit, production, and longevity


# Loading packages --------------------------------------------------------
extrafont::loadfonts(device = "win")

require(tidyverse)
require(tidylog)
require(mice)
require(fpc) # Cluster validation
require(emmeans)

# Support functions -------------------------------------------------------

# Using Rubin's rules to pool marginal means from each imputation
pool_emmeans <- function(model_list, specs) {
  
  # Initialize a list to store emmeans results
  emmeans_list <- list()
  
  # Loop over each model to compute emmeans
  for (i in 1:length(model_list)) {
    # Compute emmeans for the desired factors
    emms <- emmeans(model_list[[i]], specs = specs)
    
    # Store the emmeans object
    emmeans_list[[i]] <- emms
  }
  
  
  # Initialize data frames to store estimates and variances
  emm_estimates <- data.frame()
  emm_variances <- data.frame()
  
  for (i in 1:length(emmeans_list)) {
    # Extract estimates and standard errors
    emm_summary <- summary(emmeans_list[[i]])
    
    # Store estimates
    emm_estimates <- rbind(emm_estimates, 
                           data.frame(imputation = i, emm_summary[, c(specs, "emmean")]))
    
    # Store variances (SE^2)
    emm_variances <- rbind(emm_variances, 
                           data.frame(imputation = i, emm_summary[, c(specs, "SE")]))
  }
  
  
  
  
  # Merge estimates and variances
  emm_data <- merge(emm_estimates, emm_variances, by = c("imputation", specs))
  names(emm_data) <- c("imputation", specs, "emmean", "SE")
  
  # Compute variances
  emm_data$variance <- emm_data$SE^2
  
  # Split data by 'colostrum_sources'
  emm_split <- split(emm_data, emm_data[,specs])
  
  # Initialize a data frame to store pooled results
  pooled_emm <- data.frame()
  
  for (source in names(emm_split)) {
    # Extract data for the current source
    data_source <- emm_split[[source]]
    
    # Number of imputations
    m <- nrow(data_source)
    
    # Compute pooled estimate (mean of estimates)
    Q_bar <- mean(data_source$emmean)
    
    # Compute within-imputation variance (mean of variances)
    U_bar <- mean(data_source$variance)
    
    # Compute between-imputation variance
    B <- var(data_source$emmean)
    
    # Total variance
    T_var <- U_bar + (1 + 1/m) * B
    
    # Compute pooled standard error
    T_se <- sqrt(T_var)
    
    # Compute degrees of freedom (Rubin's rules)
    df_old <- (m - 1) * (1 + U_bar / ((1 + 1/m) * B))^2
    
    # Compute t-value for confidence intervals
    t_value <- qt(0.975, df = df_old)
    
    # Confidence intervals
    lower <- Q_bar - t_value * T_se
    upper <- Q_bar + t_value * T_se
    
    # Store results
    pooled_emm <- rbind(pooled_emm, 
                        data.frame(colostrum_sources = source,
                                   emmean = Q_bar,
                                   SE = T_se,
                                   df = df_old,
                                   lower.CL = lower,
                                   upper.CL = upper))
  }
  
  # Display the pooled estimated marginal means
  return(pooled_emm)
  
}


# Using Rubin's rules to pool pairwise comparisons

pool_pairwise <- function(model_list, specs, adjust = "tukey") {
  
  # Initialize a list to store emmeans results
  emmeans_list <- list()
  
  # Loop over each model to compute emmeans
  for (i in 1:length(model_list)) {
    # Compute emmeans for the desired factors
    emms <- emmeans(model_list[[i]], specs = specs)
    
    # Store the emmeans object
    emmeans_list[[i]] <- emms
  }
  
  
  # Initialize a list to store pairwise comparisons
  pairwise_list <- list()
  
  for (i in 1:length(emmeans_list)) {
    # Compute pairwise comparisons
    pairs_emms <- pairs(emmeans_list[[i]], adjust = adjust)
    
    # Convert to data frame and add imputation number
    pairs_df <- as.data.frame(pairs_emms)
    pairs_df$imputation <- i
    
    # Store the results
    pairwise_list[[i]] <- pairs_df
  }
  
  
  
  # Combine all pairwise comparisons into one data frame
  pairwise_data <- do.call(rbind, pairwise_list)
  
  # Compute variances
  pairwise_data$variance <- pairwise_data$SE^2
  
  # Split data by comparison
  pairwise_split <- split(pairwise_data, pairwise_data$contrast)
  
  # Initialize a data frame to store pooled pairwise comparisons
  pooled_pairs <- data.frame()
  
  for (contrast in names(pairwise_split)) {
    # Extract data for the current contrast
    data_contrast <- pairwise_split[[contrast]]
    
    # Number of imputations
    m <- nrow(data_contrast)
    
    # Compute pooled estimate (mean of estimates)
    Q_bar <- mean(data_contrast$estimate)
    
    # Compute within-imputation variance (mean of variances)
    U_bar <- mean(data_contrast$variance)
    
    # Compute between-imputation variance
    B <- var(data_contrast$estimate)
    
    # Total variance
    T_var <- U_bar + (1 + 1/m) * B
    
    # Compute pooled standard error
    T_se <- sqrt(T_var)
    
    # Compute degrees of freedom (Rubin's rules)
    df_old <- (m - 1) * (1 + U_bar / ((1 + 1/m) * B))^2
    
    # Compute t-statistic and p-value
    t_stat <- Q_bar / T_se
    p_value <- 2 * pt(-abs(t_stat), df = df_old)
    
    # Confidence intervals
    t_value <- qt(0.975, df = df_old)
    lower <- Q_bar - t_value * T_se
    upper <- Q_bar + t_value * T_se
    
    # Store results
    pooled_pairs <- rbind(pooled_pairs, 
                          data.frame(contrast = contrast,
                                     estimate = Q_bar,
                                     SE = T_se,
                                     df = df_old,
                                     t.ratio = t_stat,
                                     p.value = p_value,
                                     lower.CL = lower,
                                     upper.CL = upper))
  }
  
  # Create compact letter display
  # First, create a matrix of p-values
  contrasts <- strsplit(pooled_pairs$contrast, " - ")
  levels <- unique(unlist(contrasts))
  p_matrix <- matrix(1, nrow = length(levels), ncol = length(levels),
                     dimnames = list(levels, levels))
  
  for (i in 1:nrow(pooled_pairs)) {
    contrast <- pooled_pairs$contrast[i]
    p_value <- pooled_pairs$p.value[i]
    groups <- unlist(strsplit(contrast, " - "))
    p_matrix[groups[1], groups[2]] <- p_value
    p_matrix[groups[2], groups[1]] <- p_value
  }
  
  # Use multcompView to generate the compact letter display
  letters <- multcompView::multcompLetters(p_matrix, threshold = 0.05)
  
  # Add letters to the pooled_emms data frame
  cld <- data.frame(level = names(letters$Letters),
                    Letters = letters$Letters) %>% 
    `rownames<-`( NULL )
  
  
  # Return results as a list
  return(list(pooled_pairs = pooled_pairs, "Compact letter display" = cld))
  
}




# Reading data ------------------------------------------------------------

data.path <- "C:/Users/gabri/Documents/Doutorado/Data - PhD/Calf Survey + DHI + proAction/"


pa <- readRDS(paste(data.path, "proAction_anon_hrd_tbl.rds", sep = ""))
lpl <- readRDS(paste(data.path, "prod_lifetime_anon_anm_tbl.rds", sep = ""))
research_data <- readRDS(paste(data.path, "res_data_anon_anm_tbl.rds", sep = ""))
survey <- readRDS(paste(data.path, "survey_calf_feed_anon_tbl.rds", sep = ""))
hsi <- readRDS(paste(data.path, "whi_indicators_anon_tbl.rds", sep = ""))


# Creating a more readable herd ID

unique_hrd_id <- pa %>% 
  select(id) %>% 
  drop_na() %>% 
  rbind(lpl %>% select(id),
        research_data %>% select(id),
        survey %>% select(id),
        hsi %>%  select(id)) %>% 
  distinct(id) %>% 
  mutate(hrd_id = seq_along(id))



# Preparing data ----------------------------------------------------------

## 3+ lactation data ####

hsi1 <- hsi %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  select(hrd_id, setdiff(names(hsi), c("id"))) %>% 
  
  
  # Keeping only the last 12 months starting at the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(test_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  
  
  # Keeping only herds with at least 3 tests over the 12 month period
  filter(cnttests >= 3) %>% 
  

  # Calculating a final average per herd
  select(hrd_id, avg_pcntg_lgvt) %>% 
  group_by(hrd_id) %>% 
  summarise_if(is.numeric, mean, na.rm = T) %>% 
  ungroup()




# Getting count of animals

hsi %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  select(hrd_id, setdiff(names(hsi), c("id"))) %>% 
  
  
  # Keeping only the last 12 months starting at the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(test_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  drop_na(avg_pcntg_lgvt) %>%
  count()


# Getting count of unique herds

hsi %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  select(hrd_id, setdiff(names(hsi), c("id"))) %>% 
  
  
  # Keeping only the last 12 months starting at the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(test_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  drop_na(avg_pcntg_lgvt) %>%
  distinct(hrd_id) %>% 
  count()




## Length of productive life data ####

lpl1 <- lpl %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  
  # Keeping only data from animals that left the herd in the last 12 months prior to 
  # the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(left_herd_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  
  # Remove negative values on LPL
  filter(prod_lt > 0) %>% 
  
  # Convert LPL to year
  mutate(lpl = prod_lt/365.25) %>% 
  select(hrd_id, lpl) %>% 
  
  group_by(hrd_id) %>% 
  summarise(lpl = mean(lpl))



# Getting count of animals

lpl %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  
  # Keeping only data from animals that left the herd in the last 12 months prior to 
  # the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(left_herd_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  drop_na(prod_lt) %>%
  count()


# Getting count of unique herds

lpl %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  
  # Keeping only data from animals that left the herd in the last 12 months prior to 
  # the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(left_herd_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  drop_na(prod_lt) %>%
  distinct(hrd_id) %>% 
  count()




## Production data ####

# On research data, production and economics are provided by lactation
# Some animals moved between herds. For those animals, I am keeping
# production to the herd in which the cow finished her lactation

research_data1 <- research_data %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  
  # Keeping only data from animals that finished the lactation in the last 12 months prior to 
  # the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(lct_end_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  
  
  # Removing NAs on production variables because I need complete 
  # obs to calculate ECM. Also, removing production values of ZERO
  
  # There are also some Zeros and NAs on milk value, despite having info
  # on production. Removing this observations as well.
  
  drop_na(c(lact_date_yld_milk, lact_date_yld_fat,
            lact_date_yld_prot, cumul_milk_value)) %>% 
  
  filter(lact_date_yld_milk != 0,
         lact_date_yld_fat != 0,
         lact_date_yld_prot != 0,
         cumul_milk_value != 0) %>% 
  
  # Calculate ECM
  mutate(ecm = 12.55*lact_date_yld_fat + 
           7.39*lact_date_yld_prot + 
           0.2595*lact_date_yld_milk) %>%
  
  # For animals that moved between herds, keeping only the data up to when they 
  # stayed in their original herd. Otherwise the early life mgmt practices would 
  # be confounded with the new herd environment (e.g., the cow benefits from a
  # better ventilation system in the new herd, so her production/milk value might 
  # be improved relative to having stayed in her previous herd)
  
  arrange(anm_id_anon, lct_start_date) %>%  # Arrange data by animal ID and start date
  
  group_by(anm_id_anon) %>%
  
  mutate(first_hrd_id = first(hrd_id),  # Get the first herd ID for each animal
         hrd_change = (hrd_id != first_hrd_id)) %>%  # Flag herd changes
  filter(!hrd_change) %>%  # Keep records before the herd change
  ungroup() %>% 
  
  # Keeping variables of interest
  
  select(hrd_id, anm_id_anon, lact_date_yld_milk, lact_date_yld_fat, 
         lact_date_yld_prot, cumul_milk_value, ecm) %>% 
  
  group_by(hrd_id, anm_id_anon) %>% 
  summarise(across(everything(), sum)) %>% 
  
  
  # Calculate cumulative herd average
  select(-anm_id_anon) %>% 
  group_by(hrd_id) %>% 
  summarise_if(is.numeric, mean)




# Getting count of animals

research_data %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  
  # Keeping only data from animals that finished the lactation in the last 12 months prior to 
  # the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(lct_end_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  distinct(anm_id_anon) %>%
  count()


# Getting count of unique herds

research_data %>% 
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  
  # Keeping only data from animals that finished the lactation in the last 12 months prior to 
  # the proAction evaluation
  mutate(period = as.numeric(as.Date(visit_date, format = "%V-%m-%d") - 
                               as.Date(lct_end_date, format = "%V-%m-%d"))) %>%
  filter(period <= 365.25) %>% 
  distinct(hrd_id) %>% 
  count()







## Calf survey data ####
sv <- survey %>%
  
  # Assigning a more readable herd ID
  drop_na(id) %>% 
  left_join(unique_hrd_id, by = "id") %>% 
  select(hrd_id, setdiff(names(survey), c("id"))) %>% 
  
  # There are some empty cells, converting those to NA
  mutate(across(where(is.character), ~ na_if(.x, ""))) %>% 
  droplevels() %>%
  
  # Recorded date is in a format that does not work well with R
  mutate(recorded_date = lubridate::date(recorded_date)) %>% 
  mutate_if(is.character, as.factor) %>% 
   
  # removing repeated variables
  select(-crh_cd, -fch_cd)



# Exploring calf survey data
summary(sv)

# Exploring and potentially fixing missing observations
DataExplorer::plot_missing(sv)


# First round of cleaning

sv1 <- sv %>%  
  
  # Removing observations on Organic farms
  filter(regime == "Conventional") %>% 
  
  # Only interested in female calves. Therefore, removing the variables describing
  # how male calves are treated differently than female.
  select(-c(gender_management_ind, calf_management_reasons_1, calf_management_reasons_2,
            calf_management_reasons_3, calf_management_reasons_4, calf_management_reasons_5)) %>%
  
  # There are too many missing observations on how the farmer check the criteria used for first
  # breeding and weaning (estimated or measured/weighed). Removing this variables
  select(-c(first_brdng_msrmnt_mthds, weaning_msrmnt_mthds)) %>%
  
  # There are also a considerable number of missing data on the amount of Fat and Protein
  # of the milk replacer. Though the majority, not all farms fed milk replacer to calves.
  # Imputing zero for those farms that did not and seeing if this reduce the amount of NAs
  mutate(milk_replacer_fat_pcnt = ifelse(!is.na(calf_milk_sources) & 
                                           calf_milk_sources != "Powdered milk replacer", 0,
                                         milk_replacer_fat_pcnt),
         milk_replacer_prt_pcnt = ifelse(!is.na(calf_milk_sources) & 
                                           calf_milk_sources != "Powdered milk replacer", 0,
                                         milk_replacer_prt_pcnt)) %>% 
  
  
  # Farms that do not use milk replacer are not differentiated on the question whether milk replacer
  # is medicated. Combining both questions into one
  mutate(milk_replacer_medicated_ind = ifelse(milk_replacer_medicated_ind == 0, "Not_medicated",
                                              ifelse(milk_replacer_medicated_ind == 1, "Medicated",
                                                     milk_replacer_medicated_ind))) %>% 
  mutate(calf_milk_sources = as.character(calf_milk_sources)) %>% 
  mutate(calf_milk_sources = ifelse(calf_milk_sources == "Powdered milk replacer",
                                    paste(calf_milk_sources, milk_replacer_medicated_ind,
                                          sep = "_"),
                                    calf_milk_sources)) %>% 
  select(-milk_replacer_medicated_ind) %>% 
  
  # There are farms which responded more than one type of bedding. Combining both into a single
  # variable 
  unite(col = calf_bedding_type, 
        calf_bedding_type_1, calf_bedding_type_2,
        na.rm = TRUE, remove = TRUE) %>% 
  
  
  # Colostrum source form was not asked to farms that used powdered colostrum
  # Indicating that by creating a category level "Not applicable"
  mutate(colostrum_source_forms = as.character(colostrum_source_forms)) %>%
  mutate(colostrum_source_forms = ifelse(colostrum_sources == "Powdered colostrum",
                                           "Not applicable",
                                         colostrum_source_forms)) %>%
  
  
  # # Combining milk form and source into one variable
  # unite(col = calf_milk,
  #       calf_milk_sources, calf_milk_source_forms,
  #       na.rm = TRUE, remove = TRUE) %>% 
  # 
  
  # Combining both non-weaned and weaned housing information into one single variable for each 
  # animal category
  # unite(col = noweaned_housing,
  #       noweaned_housing_groupings, noweaned_housing_details,
  #       na.rm = TRUE, remove = TRUE) %>% 
  # unite(col = weaned_housing,
  #       weaned_housing_groupings, weaned_housing_details,
  #       na.rm = TRUE, remove = TRUE) %>% 
  
  # The variable frequency of adding bedding is on a lot of different units (per day, per week,
  # and per month). Converting it to only months
  
  # Day to month = Frequency * 365.25 (days in the year) divided by 12 months
  # Week to month = Frequency * (365.25/7) divided by 12 months
  mutate(bdng_added_fqcy = ifelse(frequency_units == "month",
                                  bdng_added_fqcy, 
                                  ifelse(frequency_units == "week",
                                         (bdng_added_fqcy*(365.25/7))/12, 
                                         ifelse(frequency_units == "day",
                                                (bdng_added_fqcy*365.25)/12, 
                                                bdng_added_fqcy)))) %>% 
  select(-frequency_units) %>% 
  mutate_if(is.character, as.factor) %>% 
  droplevels()


sv1 %>% 
  DataExplorer::plot_missing()


sv1 %>% 
  DataExplorer::plot_bar()



sv2 <- sv1 %>% 
  mutate_if(is.factor, as.character) %>% 
  mutate(systraite = ifelse(systraite == "4. N/A", NA, systraite),
         # There are too little farms with first colostrum from 7 to more than 12 hrs. Since colostrum is
         # best only if fed in the first 6 hours, I am combining the least frequent levels
         
         first_colostrum_hrs = ifelse(first_colostrum_hrs %in% c("From 7 to 12hrs", 
                                                                 "More than 12hrs"),
                                      "More than 6hrs", first_colostrum_hrs),
         # # Most farms do not evaluate colostrum IGG content. Therefore, the variable have too few
         # # answers on levels other than "Not evaluated". Changing the variable to yes or no to evaluating 
         # # colostrum IGG
         # igg_conc_eval = ifelse(is.na(igg_conc_method), NA,
         #                        ifelse(igg_conc_method == "Not evaluated", "no", "yes")),
         
         # calf_milk_feed_sys has too many levels with very little responses. Combining the least
         # common answers to level "other"
         calf_milk_feed_sys = ifelse(is.na(calf_milk_feed_sys), NA,
                                     ifelse(!(calf_milk_feed_sys %in% c("Individual bucket with teats",
                                                                        "Individual bucket without teats",
                                                                        "Bottle",
                                                                        "Automatique feeding system",
                                                                        "Feed line (free feed)")),
                                            "other", calf_milk_feed_sys)),
         
         # Very few farms answered weaning the animals "From 71 to 90" and "More than 90". Combining these
         # answers to a new level "More than 70" 
         weaning_age_days = ifelse(is.na(weaning_age_days), NA,
                                   ifelse(weaning_age_days %in% c("From 71 to 90", "More than 90"),
                                          "More than 70", weaning_age_days)),
         
         # Only 9 farms said Non pasturized / Acidified or Pasteurized / Acidified.
         # Grouping it into other
         calf_milk_source_forms = ifelse(calf_milk_source_forms  %in% 
                                           c("Non pasturized / Acidified", 
                                             "Pasteurized / Acidified"),
                                         "other", calf_milk_source_forms)
         
  ) %>% 
  
  
  # Removing herd that said not feeding colostrum to calves
  filter(colostrum_sys != "No colostrum offered") %>% 
  
  # Two farms said 0 litres of colostrom, though it was a mistake since they said using a cow
  # or a bucket to feed colostrum. Replacing it for missing data
  mutate(first_colostrum_liters = ifelse(first_colostrum_liters == "0 litre",
                                         NA, first_colostrum_liters)) %>% 
  
  
  mutate_if(is.character, factor) %>% 
  mutate_at(c("hrd_id"), factor) %>% 
  mutate_at("starter_feed_prot_pcnts", as.character) %>% 
  mutate_at("starter_feed_prot_pcnts", as.numeric) %>% 
  droplevels()


summary(sv2)

# Checking categorical variables
sv2 %>% 
  DataExplorer::plot_bar()



# Looking at the numerical variables
sv2 %>% 
  DataExplorer::plot_histogram()


# There seem to be a problem with bedding change frequency. Some farms answered adding bedding
# 3, 4, and 7 time per day, which seems a little too much! It could be a mistake in selecting the 
# correct frequency unit (i.e., maybe they meant 7 times per week for example) or it could be that 
# they check on calves multiple times per day and they add bedding if it is needed. Since there is 
# no way a could confirm that, I will leave that variable like that.


# Looking at correlations

DataExplorer::plot_correlation(sv2,
                               type = "continuous",
                               cor_args = list(use = "pairwise.complete.obs"))

DataExplorer::plot_correlation(sv2 %>% 
                                 select(-c(hrd_id, systraite, regime, # only conventional 
                                           recorded_date)),
                               type = "discrete",
                               cor_args = list(use = "pairwise.complete.obs"))


sv3 <- sv2 %>% 
  
  # colostrum and milk meals are EXACTLY the same! Combining both
  select(-milk_mealsperday) %>%
  rename(colost_AND_milk_mealsperday = colostrum_mealsperday) %>% 
  
  # Some variables are ordered (e.g., Amount of colostrum). Format this variables
  # by removing the ordering
  mutate(calf_removal_hrs = factor(calf_removal_hrs,
                                   levels = c("Less than 1hr", "1 to 6hrs", "7 to 12hrs", "13 to 24hrs",
                                              "More than 24hrs"),
                                   ordered = FALSE),
         first_colostrum_hrs = factor(first_colostrum_hrs,
                                      levels = c("Less than 1h after birth", "From 1 to 6hrs",
                                                 "More than 6hrs"),
                                      ordered = FALSE),
         colost_AND_milk_mealsperday = factor(colost_AND_milk_mealsperday,
                                              levels = c("1", "2", "3"),
                                              ordered = FALSE),
         first_colostrum_liters = factor(first_colostrum_liters,
                                         levels = c("1 litre", "2 litres", 
                                                    "3 litres", "4 litres or more"),
                                         ordered = FALSE),
         subs_colostrum_liters = factor(subs_colostrum_liters,
                                         levels = c("0 litre", "1 litre", "2 litres", 
                                                    "3 litres", "4 litres or more"),
                                         ordered = FALSE),
         weaning_age_days = factor(weaning_age_days,
                                   levels = c("Less than 50", "From 51 to 70",
                                              "More than 70"),
                                   ordered = FALSE))
  

sv3 %>% 
  DataExplorer::plot_missing()

DataExplorer::plot_correlation(sv3 %>% 
                                 select(-c(hrd_id, systraite, regime, # only conventional 
                                           recorded_date)),
                               type = "discrete",
                               cor_args = list(use = "pairwise.complete.obs"))


# Merging survey data with longevity, production, and performance

wd1 <- sv3 %>% 
  
  mutate(hrd_id = as.numeric(as.character(hrd_id))) %>% 
  left_join(research_data1, by = "hrd_id") %>% 
  left_join(hsi1 %>% 
              select(hrd_id, avg_pcntg_lgvt),
            by = "hrd_id") %>% 
  rename(lact3plus = avg_pcntg_lgvt) %>% 
  left_join(lpl1,
            by = "hrd_id") %>%
  drop_na(cumul_milk_value, ecm, lact3plus, lpl)

summary(wd1)


wd2 <- wd1 %>% 
  
  # Some levels on colostrum system, colostrum source, and colostrum_source_forms 
  # too low. Therefore, I will remove those levels
  filter(colostrum_sys != "Other",
         colostrum_sources != "Other",
         colostrum_source_forms != "Frozen pasteurized") %>%
  
  # Colostrum form was only asked to farmers who do not use powdered colostrum
  # Combining the two questions simply into one question
  mutate(colostrum_sources = as.factor(ifelse(colostrum_sources != "Powdered colostrum",
                                     paste(colostrum_sources, colostrum_source_forms,
                                           sep = "_"),
                                     as.character(colostrum_sources)))) %>% 
  select(-colostrum_source_forms) %>% 
  droplevels()

summary(wd2)


# Summary metrics for the paper
length(unique(wd2$hrd_id))
summary(wd2$recorded_date)


# Avaliando a dispersão das parcelas perdidas

n.NA <- wd2 %>%
  select(-c(hrd_id, regime, # only conventional 
            recorded_date, systraite)) %>% 
  summarise_all(~sum(is.na(.))) %>% 
  reshape2::melt(value.name = "n.NA")

n.NON_NA <- wd2 %>%
  select(-c(hrd_id, regime, # only conventional 
            recorded_date, systraite)) %>% 
  summarise_all(~sum(!is.na(.))) %>% 
  reshape2::melt(value.name = "non.NA")




n.NA %>%
  left_join(n.NON_NA, by = "variable") %>%
  mutate(percNA = round((n.NA/as.integer(count(wd2)))*100, 1)) %>% View()


# Clustering early life management practices  -------------------------
# Description of early life management practices

# Using the Gower distance because there are both categorical and numerical variables
# Also, using the daisy function from the cluster package because it accept NA

cluster.data <- wd2 %>% 
  select(-c(hrd_id, regime, # only conventional 
         recorded_date, systraite, lact_date_yld_milk, lact_date_yld_fat, 
         lact_date_yld_prot, cumul_milk_value, ecm, lact3plus, lpl))



clust.dist <- cluster::daisy(cluster.data,
                             metric = "gower")



## Cluster Validation ####

# Jaccard's bootstrap distance
# Hierarchical with Ward method

valid.ward <- data.frame(NULL)


for(i in 2:7) {
  
  cbv <- clusterboot(data = as.dist(clust.dist),
                     distances = TRUE,
                     B = 100,
                     bootmethod = "boot",
                     clustermethod = disthclustCBI,
                     noisemethod = FALSE,
                     k = i,
                     method = "ward.D2",
                     seed = 1801,
                     count = FALSE)
  
  
  valid.ward <- valid.ward %>% 
    rbind(data.frame(n_clusters = rep(cbv$nc, length(cbv$bootmean)),
                     cluster_ID = c(1:length(cbv$bootmean)),
                     jacard_boot = cbv$bootmean))
  
  print(
    paste(i, " cluster finished. Only ", 7-i, " missing :)",
          sep = "")
  )
  
}


# Partitioning around medoids

valid.pam <- data.frame(NULL)

for(i in 2:7){
  
  cbv <- clusterboot(data = as.dist(clust.dist),
                     distances = TRUE,
                     B = 100,
                     bootmethod = "boot",
                     clustermethod = claraCBI,
                     noisemethod = FALSE,
                     k = i,
                     usepam = TRUE,
                     seed = 1801,
                     count = FALSE)
  
  valid.pam <- valid.pam %>% 
    rbind(data.frame(n_clusters = rep(cbv$nc, length(cbv$bootmean)),
                     cluster_ID = c(1:length(cbv$bootmean)),
                     jacard_boot = cbv$bootmean))
  
  print(
    paste(i, " cluster finished. Only ", 7-i, " missing :)",
          sep = "")
  )
  
}



# normal mixture model

valid.mclust <- data.frame(NULL) 


for(i in 2:7){
  
  cbv <- clusterboot(data = as.dist(clust.dist),
                     distances = TRUE,
                     B = 100,
                     bootmethod = "boot",
                     clustermethod = distnoisemclustCBI,
                     noisemethod = FALSE,
                     k = i,
                     seed = 1801,
                     count = FALSE)
  
  valid.mclust <- valid.mclust %>% 
    rbind(data.frame(n_clusters = rep(cbv$nc, length(cbv$bootmean)),
                     cluster_ID = c(1:length(cbv$bootmean)),
                     jacard_boot = cbv$bootmean))
  
  print(
    paste(i, " cluster finished. Only ", 7-i, " missing :)",
          sep = "")
  )
  
}




valid.ward %>% 
  group_by(n_clusters) %>% 
  summarise(avg_jacard = mean(jacard_boot)) %>% 
  mutate_all(round, 2) #%>% 
  # rhandsontable::rhandsontable(useTypes = FALSE)

valid.ward %>% 
  filter(n_clusters == 7) %>% 
  mutate_all(round, 2) #%>% 
  # rhandsontable::rhandsontable(useTypes = FALSE)




valid.pam %>% 
  group_by(n_clusters) %>% 
  summarise(avg_jacard = mean(jacard_boot)) %>% 
  mutate_all(round, 2) #%>% 
  # rhandsontable::rhandsontable(useTypes = FALSE)

valid.pam %>% 
  filter(n_clusters == 7) %>% 
  mutate_all(round, 2) #%>% 
  # rhandsontable::rhandsontable(useTypes = FALSE)




valid.mclust %>% 
  group_by(n_clusters) %>% 
  summarise(avg_jacard = mean(jacard_boot)) %>% 
  mutate_all(round, 2) #%>% 
  # rhandsontable::rhandsontable(useTypes = FALSE)

valid.mclust %>%  
  filter(n_clusters == 7) %>% 
  mutate_all(round, 2) #%>% 
  # rhandsontable::rhandsontable(useTypes = FALSE)


# Normal mixture model-based with 2 clusters was the best option!


## Clustering ####

set.seed(1801)
sv.cluster <- distnoisemclustCBI(dmatrix = as.dist(clust.dist),
                                 k = 2,
                                 diss = TRUE)



# Visualizing the clusters using MDS
cluster_mds <- cmdscale(d = as.dist(clust.dist),
                        k = 2, # First two dimensions
                        eig = TRUE)




# Visualizing the cluster results on nlPCA loads

ggplot(mapping = aes(x = cluster_mds$points[,1],
                     y = cluster_mds$points[,2],
                     color = factor(sv.cluster$partition),
                     shape = factor(sv.cluster$partition))) +
  geom_point(alpha = 0.6, size = 1) +
  scale_color_manual(values = c("#1F78B4", "#FF7F00")) +
  
  theme_bw(base_family = "Times New Roman") +
  labs(x = "MDS1",
       y = "MDS2",
       shape = "Cluster",
       colour = "Cluster") +

  theme(axis.text = element_text(size = 10, color = "black"),
        legend.text = element_text(size = 10, family = "Times New Roman"),
        legend.position = "right", #c(0.91, 0.812),
        # legend.backgr→ound = element_rect(fill = "white", color = "black"),
        legend.justification="center",
        axis.title.x = element_text(size = 10, 
                                    margin = margin(t = 10, # top
                                                    r = 0, # right 
                                                    b = 0, # bottom
                                                    l = 0)),  # left
        axis.title.y = element_text(size = 10,
                                    margin = margin(t = 0, # top
                                                    r = 10, # right 
                                                    b = 0, # bottom
                                                    l = 0)),
        legend.title.align = 0.5)


ggsave("Submitted/Images/MDS_Clusters.jpeg",
       width = 13,
       height = 8,
       units = "cm",
       dpi = 700)


table(sv.cluster$partition)


## Describing clusters ####
# In order to describe the clusters, I will be using a simpler methodology.
# I will use the v-test from the FactoMineR package. It provides a straight 
# forward way to identify which variables clearly describe a cluster compared to the 
# population.

sv.cluster.desc <- FactoMineR::catdes(donnee = cluster.data %>% 
                                        mutate(cluster = factor(sv.cluster$partition)),
                                      num.var = ncol(cluster.data)+1,
                                      proba = 0.05)


# Cluster 1

sv.cluster.desc$category$`1` %>%
  data.frame() %>%
  rownames_to_column("variable") %>%
  arrange(desc(v.test)) %>%
  mutate_if(is.numeric, round, 1) %>%
  head(10) #%>%  
  # rhandsontable::rhandsontable(useTypes = FALSE)



sv.cluster.desc$quanti$`1` %>%
  data.frame() %>%
  rownames_to_column("variable") %>%
  arrange(desc(v.test)) %>%
  mutate_if(is.numeric, round, 1) %>%
  head(10) #%>%  
  # rhandsontable::rhandsontable(useTypes = FALSE)




# Cluster 2
sv.cluster.desc$category$`2` %>%
  data.frame() %>%
  rownames_to_column("variable") %>%
  arrange(desc(v.test)) %>%
  mutate_if(is.numeric, round, 1) %>%
  head(10) #%>%  
  # rhandsontable::rhandsontable(useTypes = FALSE)


sv.cluster.desc$quanti$`2` %>%
  data.frame() %>%
  rownames_to_column("variable") %>%
  arrange(v.test) %>%
  mutate_if(is.numeric, round, 1) %>%
  head(10) #%>%  
  # rhandsontable::rhandsontable(useTypes = FALSE)


# Creating data file with cluster labels

wd3 <- wd2 %>% 
  mutate(cluster = factor(sv.cluster$partition)) 

wd3 %>% 
  select(lpl, lact3plus, ecm, cumul_milk_value) %>% 
  summary()


# Exploring missing observations
DataExplorer::plot_missing(wd3)
summary(wd3)


  
ggplot(wd3, aes(x = cluster, y = ecm)) +
  geom_boxplot()

ggplot(wd3, aes(x = cluster, y = cumul_milk_value)) +
  geom_boxplot()


ggplot(wd3, aes(x = cluster, y = lact3plus)) +
  geom_boxplot()

ggplot(wd3, aes(x = cluster, y = lpl)) +
  geom_boxplot()


wd3 %>% 
  select(lpl, lact3plus, ecm, cumul_milk_value) %>% 
  summarise_if(is.numeric, mean) %>% 
  data.frame() %>% 
  mutate_if(is.numeric, round, 1)



# Descriptive stats per cluster
wd3 %>%  
  group_by(cluster) %>% 
  summarise_at("lpl", mean, na.rm = T) %>% 
  data.frame() %>% 
  mutate_if(is.numeric, round, 1)


wd3 %>%  
  group_by(cluster) %>% 
  summarise_at("lpl", sd, na.rm = T) %>% 
  data.frame() %>% 
  mutate_if(is.numeric, round, 1)

  


# Multiple imputation -----------------------------------------------------


# Creating prediction matrix to no use the outcome variables during the imputation

pred <- make.predictorMatrix(wd3 %>%
                               select(-c(hrd_id, systraite, regime, # only conventional 
                                         recorded_date, lact_date_yld_milk, lact_date_yld_fat,
                                         lact_date_yld_prot, cluster)))

# Do not impute outcome variables and do not use them to impute other variables
pred[c("ecm", "cumul_milk_value", "lact3plus", "lpl"), ] <- 0
pred[, c("ecm", "cumul_milk_value", "lact3plus", "lpl")] <- 0


# Defining random forest method for all survey variables
meth <- make.method(wd3 %>%
                      select(-c(hrd_id, systraite, regime, # only conventional 
                                recorded_date, lact_date_yld_milk, lact_date_yld_fat,
                                lact_date_yld_prot, cluster)),
                    defaultMethod = c("rf", "rf", "rf", "rf"))

meth[c("ecm", "cumul_milk_value", "lact3plus", "lpl")] <- ""



# Multiple imputation

wd.imputed <- mice(data = wd3 %>%
                     select(-c(hrd_id, systraite, regime, # only conventional 
                               recorded_date, lact_date_yld_milk, lact_date_yld_fat,
                               lact_date_yld_prot, cluster)), 
                   method = meth,
                   predictorMatrix = pred,
                   seed = 1801,
                   m = 10,
                   maxit = 40,
                   printFlag = TRUE)



# Evaluating algorithmic convergence

# The plot shows the mean (left) and standard deviation (right) of the imputed 
# values only. In general, we would like the streams to intermingle and be free
# of any trends at the later iterations 
# (https://www.gerkovink.com/miceVignettes/Convergence_pooling/Convergence_and_pooling.html)

plot(wd.imputed)



# Imputed values should be plausible (i.e., could have been observed if they had
# not been missing. In order to form an idea about plausibility, one may check the 
# imputations and compare them against the observed values.

stripplot(wd.imputed)



# LPL ---------------------------------------------------------------------

# Define the full model formula
predictor_vars <- names(wd.imputed$data)
predictor_vars <- setdiff(predictor_vars, c("ecm", "cumul_milk_value", "lact3plus", "lpl"))
full_formula <- paste(predictor_vars, collapse = " + ")

# Fit the full model on each imputed dataset
full_models.lpl <- with(wd.imputed, lm(as.formula(paste("lpl ~", full_formula))))

# Initialize objects
current_vars.lpl <- predictor_vars
continue_selection <- TRUE
iteration <- 1


while (continue_selection) {
  cat("\nIteration:", iteration, "\n")
  
  # List to store p-values for each variable
  variable_pvalues.lpl <- data.frame(variable = current_vars.lpl, p_value = NA)
  
  # For each variable, perform a joint significance test
  for (var in current_vars.lpl) {
    # Define reduced formula (without the current variable)
    reduced_vars <- setdiff(current_vars.lpl, var)
    reduced_formula <- paste(reduced_vars, collapse = " + ")
    
    # Fit reduced models on each imputed dataset
    reduced_models <- with(wd.imputed, lm(as.formula(paste("lpl ~", reduced_formula))))
    
    # Pool likelihood ratio test between full and reduced model (i.e., D3 method)
    pooled_anova <- mice::D3(full_models.lpl, reduced_models)
    
    # Extract the p-value for the variable
    p_value <- pooled_anova$result[4]
    variable_pvalues.lpl$p_value[variable_pvalues.lpl$variable == var] <- p_value
  }
  
  # Display the p-values
  print(variable_pvalues.lpl)
  
  # Identify the variable with the highest p-value
  max_pvalue <- max(variable_pvalues.lpl$p_value, na.rm = TRUE)
  variable_to_remove <- variable_pvalues.lpl$variable[variable_pvalues.lpl$p_value == max(variable_pvalues.lpl$p_value, na.rm = TRUE)]
  
  if (max_pvalue < 0.05) {
    # All variables are significant; stop the selection
    continue_selection <- FALSE
    cat("All remaining variables are significant.\n")
  } else {
    # Remove the variable with the highest p-value
    cat("Removing variable:", variable_to_remove, "with p-value:", max_pvalue, "\n")
    current_vars.lpl <- setdiff(current_vars.lpl, variable_to_remove)
    
    # Update the full models without the removed variable
    if (length(current_vars.lpl) == 0) {
      cat("No predictors left in the model.\n")
      continue_selection <- FALSE
    } else {
      full_formula <- paste(current_vars.lpl, collapse = " + ")
      full_models.lpl <- with(wd.imputed, lm(as.formula(paste("lpl ~", full_formula))))
      iteration <- iteration + 1
    }
  }
}


# Final variables p-values
variable_pvalues.lpl

# Fit the final model
final_models.lpl <- full_models.lpl

# Pool the final model results
final_pooled.lpl <- pool(final_models.lpl)

# Display the final model summary
summary(final_pooled.lpl) %>% 
  mutate(p.value = round(p.value, 3))




## Marginal means and multiple comparisons ---------------------------------

pool_emmeans(model_list = final_models.lpl$analyses,
             specs = "colostrum_sources") %>% 
  mutate(emmean = round(emmean, 2),
         SE = round(SE, 2))

pool_pairwise(model_list = final_models.lpl$analyses,
              specs = "colostrum_sources",
              adjust = "tukey")


pool_emmeans(model_list = final_models.lpl$analyses,
             specs = "first_colostrum_liters") %>% 
  mutate(emmean = round(emmean, 2),
         SE = round(SE, 2))

pool_pairwise(model_list = final_models.lpl$analyses,
              specs = "first_colostrum_liters",
              adjust = "tukey")


pool_emmeans(model_list = final_models.lpl$analyses,
             specs = "calf_milk_source_forms") %>% 
  mutate(emmean = round(emmean, 2),
         SE = round(SE, 2))

pool_pairwise(model_list = final_models.lpl$analyses,
              specs = "calf_milk_source_forms",
              adjust = "tukey")



# Percentage of 3+ Lactation ----------------------------------------------

# Define the full model formula
predictor_vars <- names(wd.imputed$data)
predictor_vars <- setdiff(predictor_vars, c("ecm", "cumul_milk_value", "lact3plus", "lpl"))
full_formula <- paste(predictor_vars, collapse = " + ")

# Fit the full model on each imputed dataset
full_models.lact3plus <- with(wd.imputed, lm(as.formula(paste("lact3plus ~", full_formula))))

# Initialize objects
current_vars.lact3plus <- predictor_vars
continue_selection <- TRUE
iteration <- 1


while (continue_selection) {
  cat("\nIteration:", iteration, "\n")
  
  # List to store p-values for each variable
  variable_pvalues.lact3plus <- data.frame(variable = current_vars.lact3plus, p_value = NA)
  
  # For each variable, perform a joint significance test
  for (var in current_vars.lact3plus) {
    # Define reduced formula (without the current variable)
    reduced_vars <- setdiff(current_vars.lact3plus, var)
    reduced_formula <- paste(reduced_vars, collapse = " + ")
    
    # Fit reduced models on each imputed dataset
    reduced_models <- with(wd.imputed, lm(as.formula(paste("lact3plus ~", reduced_formula))))
    
    
    # Pool likelihood ratio test between full and reduced model (i.e., D3 method)
    pooled_anova <- mice::D3(full_models.lact3plus, reduced_models)
    
    # Extract the p-value for the variable
    p_value <- pooled_anova$result[4]
    variable_pvalues.lact3plus$p_value[variable_pvalues.lact3plus$variable == var] <- p_value
  }
  
  # Display the p-values
  print(variable_pvalues.lact3plus)
  
  # Identify the variable with the highest p-value
  max_pvalue <- max(variable_pvalues.lact3plus$p_value, na.rm = TRUE)
  variable_to_remove <- variable_pvalues.lact3plus$variable[variable_pvalues.lact3plus$p_value == max(variable_pvalues.lact3plus$p_value, na.rm = TRUE)]
  
  # variable_pvalues.lact3plus$variable[variable_pvalues.lact3plus$p_value == max(variable_pvalues.lact3plus$p_value, na.rm = TRUE) | 
  #                                                   is.na(variable_pvalues.lact3plus$p_value)]
  
  if (max_pvalue < 0.05) {
    # All variables are significant; stop the selection
    continue_selection <- FALSE
    cat("All remaining variables are significant.\n")
  } else {
    # Remove the variable with the highest p-value
    cat("Removing variable:", variable_to_remove, "with p-value:", max_pvalue, "\n")
    current_vars.lact3plus <- setdiff(current_vars.lact3plus, variable_to_remove)
    
    # Update the full models without the removed variable
    if (length(current_vars.lact3plus) == 0) {
      cat("No predictors left in the model.\n")
      continue_selection <- FALSE
    } else {
      full_formula <- paste(current_vars.lact3plus, collapse = " + ")
      full_models.lact3plus <- with(wd.imputed, lm(as.formula(paste("lact3plus ~", full_formula))))
      iteration <- iteration + 1
    }
  }
}



# Final variables p-values
variable_pvalues.lact3plus %>% 
  mutate(p_value = round(p_value, 3))

# Fit the final model
final_models.lact3plus <- full_models.lact3plus

# Pool the final model results
final_pooled.lact3plus <- pool(final_models.lact3plus)

# Display the final model summary
summary(final_pooled.lact3plus) %>% 
  mutate(p.value = round(p.value, 3))



## Marginal means and multiple comparisons ---------------------------------

pool_emmeans(model_list = final_models.lact3plus$analyses,
             specs = "colostrum_sources") %>% 
  mutate(emmean = round(emmean, 2),
         SE = round(SE, 2))

pool_pairwise(model_list = final_models.lact3plus$analyses,
              specs = "colostrum_sources",
              adjust = "tukey")


pool_emmeans(model_list = final_models.lact3plus$analyses,
             specs = "colost_AND_milk_mealsperday") %>% 
  mutate(emmean = round(emmean, 2),
         SE = round(SE, 2))

pool_pairwise(model_list = final_models.lact3plus$analyses,
              specs = "colost_AND_milk_mealsperday",
              adjust = "tukey")


pool_emmeans(model_list = final_models.lact3plus$analyses,
             specs = "hsng_walls_cleaned_ind") %>% 
  mutate(emmean = round(emmean, 2),
         SE = round(SE, 2))

pool_pairwise(model_list = final_models.lact3plus$analyses,
              specs = "hsng_walls_cleaned_ind",
              adjust = "tukey")



# Looking at the continuous variable, but only up to quadratic term
with(wd.imputed,
     lm(lact3plus ~ colostrum_sources + colost_AND_milk_mealsperday + 
          hsng_walls_cleaned_ind + 
          first_roughages_days)) %>%
  pool() %>%
  summary()  %>%
  mutate(p.value = round(p.value, 3),
         estimate = round(estimate, 2),
         std.error = round(std.error, 2))

# Getting descriptive statistics of the continuous variables

# first_roughages_days
# Original data

mean(wd2$first_roughages_days, na.rm = T) %>% 
  round(2)
round(var(wd2$first_roughages_days, na.rm = TRUE)/sum(!is.na(wd2$first_roughages_days)),
      2)


# ECM ---------------------------------------------------------------------

# Define the full model formula
predictor_vars <- names(wd.imputed$data)
predictor_vars <- setdiff(predictor_vars, c("ecm", "cumul_milk_value", "lact3plus", "lpl"))
full_formula <- paste(predictor_vars, collapse = " + ")

# Fit the full model on each imputed dataset
full_models.ecm <- with(wd.imputed, lm(as.formula(paste("ecm ~", full_formula))))

# Initialize objects
current_vars.ecm <- predictor_vars
continue_selection <- TRUE
iteration <- 1


while (continue_selection) {
  cat("\nIteration:", iteration, "\n")
  
  # List to store p-values for each variable
  variable_pvalues.ecm <- data.frame(variable = current_vars.ecm, p_value = NA)
  
  # For each variable, perform a joint significance test
  for (var in current_vars.ecm) {
    # Define reduced formula (without the current variable)
    reduced_vars <- setdiff(current_vars.ecm, var)
    reduced_formula <- paste(reduced_vars, collapse = " + ")
    
    # Fit reduced models on each imputed dataset
    reduced_models <- with(wd.imputed, lm(as.formula(paste("ecm ~", reduced_formula))))
    
    # Pool likelihood ratio test between full and reduced model (i.e., D3 method)
    pooled_anova <- mice::D3(full_models.ecm, reduced_models)
    
    # Extract the p-value for the variable
    p_value <- pooled_anova$result[4]
    variable_pvalues.ecm$p_value[variable_pvalues.ecm$variable == var] <- p_value
  }
  
  # Display the p-values
  print(variable_pvalues.ecm)
  
  # Identify the variable with the highest p-value
  max_pvalue <- max(variable_pvalues.ecm$p_value, na.rm = TRUE)
  variable_to_remove <- variable_pvalues.ecm$variable[variable_pvalues.ecm$p_value == max(variable_pvalues.ecm$p_value, na.rm = TRUE)]
  
  # variable_to_remove <- variable_pvalues.ecm$variable[variable_pvalues.ecm$p_value == max(variable_pvalues.ecm$p_value, na.rm = TRUE) |
  #                                                       is.na(variable_pvalues.ecm$p_value)]
  
  if (max_pvalue < 0.05) {
    # All variables are significant; stop the selection
    continue_selection <- FALSE
    cat("All remaining variables are significant.\n")
  } else {
    # Remove the variable with the highest p-value
    cat("Removing variable:", variable_to_remove, "with p-value:", max_pvalue, "\n")
    current_vars.ecm <- setdiff(current_vars.ecm, variable_to_remove)
    
    # Update the full models without the removed variable
    if (length(current_vars.ecm) == 0) {
      cat("No predictors left in the model.\n")
      continue_selection <- FALSE
    } else {
      full_formula <- paste(current_vars.ecm, collapse = " + ")
      full_models.ecm <- with(wd.imputed, lm(as.formula(paste("ecm ~", full_formula))))
      iteration <- iteration + 1
    }
  }
}

# Final variables p-values
variable_pvalues.ecm %>% 
  mutate(p_value = round(p_value, 3))

# Fit the final model
final_models.ecm <- full_models.ecm

# Pool the final model results
final_pooled.ecm <- pool(final_models.ecm)

# Display the final model summary
summary(final_pooled.ecm) %>% 
  mutate(p.value = round(p.value, 3))


## Marginal means and multiple comparisons ---------------------------------

pool_emmeans(model_list = final_models.ecm$analyses,
             specs = "first_colostrum_liters") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = final_models.ecm$analyses,
              specs = "first_colostrum_liters",
              adjust = "tukey")


pool_emmeans(model_list = final_models.ecm$analyses,
             specs = "subs_colostrum_liters") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = final_models.ecm$analyses,
              specs = "subs_colostrum_liters",
              adjust = "tukey")


pool_emmeans(model_list = final_models.ecm$analyses,
             specs = "calf_milk_feed_sys") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = final_models.ecm$analyses,
              specs = "calf_milk_feed_sys",
              adjust = "tukey")


pool_emmeans(model_list = final_models.ecm$analyses,
             specs = "noweaned_housing_details") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = final_models.ecm$analyses,
              specs = "noweaned_housing_details",
              adjust = "tukey")


# Looking at the continuous variable, but only up to quadratic term
with(wd.imputed,
     lm(ecm ~ first_colostrum_liters + subs_colostrum_liters + calf_milk_feed_sys + 
          noweaned_housing_details + 
          first_concentrate_age_days + 
          first_roughages_days)) %>%
  pool() %>%
  summary() %>%
  mutate(p.value = round(p.value, 3),
         estimate = round(estimate, 2),
         std.error = round(std.error, 2))


# Getting pooled descriptive statistics of the continuous variables

# first_concentrate_age_days
# Original data

mean(wd2$first_concentrate_age_days, na.rm = T) %>% 
  round(2)
round(var(wd2$first_concentrate_age_days, na.rm = TRUE)/sum(!is.na(wd2$first_concentrate_age_days)),
      2)

# first_roughages_days

# Original data

mean(wd2$first_roughages_days, na.rm = T) %>% 
  round(2)
round(var(wd2$first_roughages_days, na.rm = TRUE)/sum(!is.na(wd2$first_roughages_days)),
      2)

# Cumulative milk value ---------------------------------------------------

# Define the full model formula
predictor_vars <- names(wd.imputed$data)
predictor_vars <- setdiff(predictor_vars, c("ecm", "cumul_milk_value", "lact3plus", "lpl"))
full_formula <- paste(predictor_vars, collapse = " + ")

# Fit the full model on each imputed dataset
full_models.cumul_milk_value <- with(wd.imputed, lm(as.formula(paste("cumul_milk_value ~", full_formula))))

# Initialize objects
current_vars.cumul_milk_value <- predictor_vars
continue_selection <- TRUE
iteration <- 1


while (continue_selection) {
  cat("\nIteration:", iteration, "\n")
  
  # List to store p-values for each variable
  variable_pvalues.cumul_milk_value <- data.frame(variable = current_vars.cumul_milk_value, p_value = NA)
  
  # For each variable, perform a joint significance test
  for (var in current_vars.cumul_milk_value) {
    # Define reduced formula (without the current variable)
    reduced_vars <- setdiff(current_vars.cumul_milk_value, var)
    reduced_formula <- paste(reduced_vars, collapse = " + ")
    
    # Fit reduced models on each imputed dataset
    reduced_models <- with(wd.imputed, lm(as.formula(paste("cumul_milk_value ~", reduced_formula))))
    

    # Pool likelihood ratio test between full and reduced model (i.e., D3 method)
    pooled_anova <- mice::D3(full_models.cumul_milk_value, reduced_models)
    
    # Extract the p-value for the variable
    p_value <- pooled_anova$result[4]
    variable_pvalues.cumul_milk_value$p_value[variable_pvalues.cumul_milk_value$variable == var] <- p_value
  }
  
  # Display the p-values
  print(variable_pvalues.cumul_milk_value)
  
  # Identify the variable with the highest p-value
  max_pvalue <- max(variable_pvalues.cumul_milk_value$p_value, na.rm = TRUE)
  variable_to_remove <- variable_pvalues.cumul_milk_value$variable[variable_pvalues.cumul_milk_value$p_value == max(variable_pvalues.cumul_milk_value$p_value, na.rm = TRUE)]
  
  # variable_to_remove <- variable_pvalues.cumul_milk_value$variable[variable_pvalues.cumul_milk_value$p_value == max(variable_pvalues.cumul_milk_value$p_value, na.rm = TRUE) | 
                                                    # is.na(variable_pvalues.cumul_milk_value$p_value)]
  
  if (max_pvalue < 0.05) {
    # All variables are significant; stop the selection
    continue_selection <- FALSE
    cat("All remaining variables are significant.\n")
  } else {
    # Remove the variable with the highest p-value
    cat("Removing variable:", variable_to_remove, "with p-value:", max_pvalue, "\n")
    current_vars.cumul_milk_value <- setdiff(current_vars.cumul_milk_value, variable_to_remove)
    
    # Update the full models without the removed variable
    if (length(current_vars.cumul_milk_value) == 0) {
      cat("No predictors left in the model.\n")
      continue_selection <- FALSE
    } else {
      full_formula <- paste(current_vars.cumul_milk_value, collapse = " + ")
      full_models.cumul_milk_value <- with(wd.imputed, lm(as.formula(paste("cumul_milk_value ~", full_formula))))
      iteration <- iteration + 1
    }
  }
}


# Final variables p-values
variable_pvalues.cumul_milk_value %>% 
  mutate(p_value = round(p_value, 3))

# Fit the final model
final_models.cumul_milk_value <- full_models.cumul_milk_value

# Pool the final model results
final_pooled.cumul_milk_value <- pool(final_models.cumul_milk_value)

# Display the final model summary
summary(final_pooled.cumul_milk_value) %>% 
  mutate(p.value = round(p.value, 3))


## Marginal means and multiple comparisons ---------------------------------



pool_emmeans(model_list = full_models.cumul_milk_value$analyses,
             specs = "first_colostrum_liters") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = full_models.cumul_milk_value$analyses,
              specs = "first_colostrum_liters",
              adjust = "tukey")


pool_emmeans(model_list = full_models.cumul_milk_value$analyses,
             specs = "subs_colostrum_liters") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = full_models.cumul_milk_value$analyses,
              specs = "subs_colostrum_liters",
              adjust = "tukey")


pool_emmeans(model_list = full_models.cumul_milk_value$analyses,
             specs = "calf_milk_feed_sys") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = full_models.cumul_milk_value$analyses,
              specs = "calf_milk_feed_sys",
              adjust = "tukey")


pool_emmeans(model_list = full_models.cumul_milk_value$analyses,
             specs = "noweaned_housing_details") %>% 
  mutate(emmean = round(emmean, 1),
         SE = round(SE, 1))

pool_pairwise(model_list = full_models.cumul_milk_value$analyses,
              specs = "noweaned_housing_details",
              adjust = "tukey")


# Looking at the continuous variable, but only up to quadratic term
with(wd.imputed,
     lm(cumul_milk_value ~ first_colostrum_liters + subs_colostrum_liters + calf_milk_feed_sys + 
          noweaned_housing_details + 
          first_concentrate_age_days + 
          first_roughages_days)) %>%
  pool() %>%
  summary() %>%
  mutate(p.value = round(p.value, 3),
         estimate = round(estimate, 2),
         std.error = round(std.error, 2))

# THE END ####################################################################

